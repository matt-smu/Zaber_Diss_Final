



Recall that Boromir drives the security metric benchmarking process and manages sample persistence. The following command generate 1000 samples of the standard set metrics for the default models defined in the environment. Setting random scores is optional, but makes non-stochastic measurements a little more interesting.

 \begin{verbatim}> ./run_boromir.py --boromir_run_count=1000 --secmet_random_cvss_scores\end{verbatim} 

When a test run kicks off, Boromir relays the user inputs and security metric specifications to PTAH to provision the system models which will be used for the test.

All facts used to build the models are conveniently collocated in XSB with the MulVal\cite{Ou_Appel_2005} attack graph engine. This allows us to solicit interaction rules from users or other processes while the models are being assembled. When a run is over, the fact base is dumped from XSB and packaged with the test's metadata, so every sample contains the information needed to recreate the environment it was taken from. 


%     \begin{Verbatim}[commandchars=\\\{\}]
%                              sample\_uri  w\_0\_0  w\_0\_1  w\_0\_2  w\_0\_3  w\_0\_4  \textbackslash{}
% 0  f3c1b87e-cad1-431f-ac63-eac72b694c84    0.0   5.49    0.0    0.0    0.0
% 1  0514df06-4242-451a-b737-41057c26dc00    0.0   7.74    0.0    0.0    0.0
% 2  a6c94818-2807-484a-83c5-d2f227a37a45    0.0   6.21    0.0    0.0    0.0
% 3  8b265a5c-f662-42fd-a8a1-f084ef4a66e1    0.0   2.05    0.0    0.0    0.0
% 4  9dc8f994-84a6-40d4-ae6d-bf1cfdba007d    0.0   7.00    0.0    0.0    0.0

%   w\_0\_5  w\_1\_0  w\_1\_1  w\_1\_2  {\ldots}  w\_4\_3  w\_4\_4  w\_4\_5  w\_5\_0  w\_5\_1  w\_5\_2  \textbackslash{}
% 0    0.0    0.0    0.0   5.81  {\ldots}    0.0    0.0   5.07    0.0    0.0    0.0
% 1    0.0    0.0    0.0   5.21  {\ldots}    0.0    0.0   6.43    0.0    0.0    0.0
% 2    0.0    0.0    0.0   1.85  {\ldots}    0.0    0.0   8.10    0.0    0.0    0.0
% 3    0.0    0.0    0.0   5.71  {\ldots}    0.0    0.0   4.82    0.0    0.0    0.0
% 4    0.0    0.0    0.0   9.67  {\ldots}    0.0    0.0   7.84    0.0    0.0    0.0

%   w\_5\_3  w\_5\_4  w\_5\_5  score
% 0    0.0    0.0    0.0   4.00
% 1    0.0    0.0    0.0  12.00
% 2    0.0    0.0    0.0  16.00
% 3    0.0    0.0    0.0   0.75
% 4    0.0    0.0    0.0  40.50

% [5 rows x 38 columns]
%     \end{Verbatim}

`

% \begin{minipage}{.95\linewidth}
% \begin{lstlisting}[language=yaml, label={lst:pandas_load},
\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1000 entries, 0 to 999
Data columns (total 5 columns):
sample_uri    1000 non-null object
reduced_ag    1000 non-null object
orig_ag       1000 non-null object
fact_graph    1000 non-null object
value         1000 non-null float64
dtypes: float64(1), object(4)
memory usage: 39.2+ KB
\end{verbatim}
\label{lst:pandas_load}
% \end{lstlisting}
% \end{minipage}

Listing \ref{lst:pandas_load} shows a dataframe holding 1000 samples from a boromir run. The \textit{sample\_uri} field is a unique uuid for each row, and \textit{value} is the result of the metric calculation. The remaining three fields hold the fact graph, the attack graph, and the adjacency matrix equivalent subgraph  of the attack graph. We describe the reduction processes provided by this framework in Section \ref{sec:automation:gen_trans_matrix}, so here we simply refer to the networkx inherited function to dump the graph as a sparse matrix. 



